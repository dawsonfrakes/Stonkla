<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stonkla</title>
</head>
<body>
  <script type="module">
    import {createElement as h, createContext, useState, useEffect, useRef, useContext, useId} from "https://esm.sh/react";
    import ReactDOMClient from "https://esm.sh/react-dom/client";

    import {Chart} from "https://esm.sh/chart.js@4.4.7/auto";

    const DB = (() => {
      const ondbchange = new CustomEvent("ondbchange");
      const inner = new Promise((resolve, reject) => {
        const request = indexedDB.open("stonkla", 1);
        request.onsuccess = e => resolve(e.target.result);
        request.onerror = e => resolve(e.target.error);
        request.onupgradeneeded = e => {
          const db = e.target.result;
          if (db.version >= 1) {
            const store = db.createObjectStore("trades", {keyPath: "id", autoIncrement: true});
            store.createIndex("symbol", "symbol");
            store.createIndex("executions", "executions");
            store.createIndex("tags", "tags");
          }
        };
      });
      return {
        add: (store, value) => inner.then(db => db.transaction(store, "readwrite").objectStore(store).add(value)).then(request => (request.onsuccess = () => document.dispatchEvent(ondbchange))),
        bulkAdd: (store, values) => inner.then(db => { const tx = db.transaction(store, "readwrite").objectStore(store); values.forEach(value => tx.add(value)); tx.transaction.oncomplete = () => document.dispatchEvent(ondbchange); }),
        put: (store, value) => inner.then(db => db.transaction(store, "readwrite").objectStore(store).put(value)).then(request => (request.onsuccess = () => document.dispatchEvent(ondbchange))),
        delete: (store, id) => inner.then(db => db.transaction(store, "readwrite").objectStore(store).delete(id)).then(request => (request.onsuccess = () => document.dispatchEvent(ondbchange))),
        clear: store => inner.then(db => db.transaction(store, "readwrite").objectStore(store).clear()).then(request => (request.onsuccess = () => document.dispatchEvent(ondbchange))),
        get: (store, id) => inner.then(db => db.transaction(store).objectStore(store).get(id)),
        getAll: store => inner.then(db => db.transaction(store).objectStore(store).getAll()),
      };
    })();

    const TRANSLATIONS = {
      "en": {
        "translation-name": "English",
        "app-add-trade-button": "Add Trade",
        "app-import-export-button": "Import/Export",
        "app-open-settings-button": "Settings",
        "trade-entry-header-text": "Trade Entry",
        "trade-entry-close-button": "Close",
        "trade-entry-symbol-placeholder": "Symbol",
        "trade-entry-symbol-label": "Symbol:",
        "trade-entry-tags-placeholder": "Tags (a;b;c)",
        "trade-entry-tags-label": "Tags:",
        "trade-entry-remove-execution-button": "Remove",
        "trade-entry-action-buy-button": "BUY",
        "trade-entry-action-sell-button": "SELL",
        "trade-entry-time-label": "Time:",
        "trade-entry-quantity-label": "Quantity:",
        "trade-entry-price-label": "Price:",
        "trade-entry-fees-label": "Fees:",
        "trade-entry-add-execution-button": "Add Execution",
        "trade-entry-save-button": "Save",
        "app-settings-header-text": "Settings",
        "app-settings-close-button": "Close",
        "app-settings-locale-label": "Locale:",
        "app-settings-theme-label": "Theme:",
        "app-settings-currency-label": "Currency:",
        "app-settings-remove-all-trades-button": "Remove All Trades",
        "app-settings-remove-all-trades-confirm": "Are you sure you want to remove all trades?",
        "trade-table-time-header": "Time",
        "trade-table-symbol-header": "Symbol",
        "trade-table-side-header": "Side",
        "trade-table-entry-total-header": "Entry Total",
        "trade-table-exit-total-header": "Exit Total",
        "trade-table-net-profit-loss-header": "Net P/L",
        "trade-table-tags-header": "Tags",
        "trade-table-edit-header": "Edit",
        "trade-table-remove-header": "Remove",
        "trade-table-side-short": "Short",
        "trade-table-side-long": "Long",
        "trade-stats-total-profit-loss-label": "Total Profit/Loss:",
        "trade-stats-total-fees-label": "Total Fees/Commissions:",
        "trade-stats-total-trades-label": "Total Trades:",
        "trade-stats-win-count-label": "Win Count:",
        "trade-stats-loss-count-label": "Loss Count:",
        "trade-stats-win-percentage-label": "Win Percentage:",
        "trade-stats-largest-win-label": "Largest Win:",
        "trade-stats-largest-loss-label": "Largest Loss:",
        "trade-stats-average-trade-label": "Average Trade:",
        "trade-stats-average-win-label": "Average Win:",
        "trade-stats-average-loss-label": "Average Loss:",
        "trade-charts-trades-won-header": "Trades Won",
        "trade-charts-equity-header": "Equity",
        "trade-charts-trades-won-relative-to-price-range-text": "Trades won relative to price range",
        "trade-charts-trades-won-relative-to-time-frame-text": "Trades won relative to time frame",
        "trade-charts-equity-curve-text": "Equity curve",
        "trade-import-export-header-text": "Import/Export",
        "trade-import-export-close-button": "Close",
        "trade-import-export-csv-type-label": "CSV Import Type:",
        "trade-import-export-csv-file-label": "CSV File:",
        "trade-import-export-import-from-csv-button": "Import from CSV",
        "trade-import-export-export-to-csv-button": "Export to CSV",
      },
    };

    const THEMES = {
      "gray-matter": {
        "background-primary": "#343434",
        "background-secondary": "#232323",
        "text-primary": "#cdcdcd",
        "text-secondary": "#fefefe",
        "accent": "#cc6655",
      },
    };

    const toLocalTime = date => new Date(date - new Date().getTimezoneOffset() * 60 * 1000).toISOString().slice(0, -1);
    const currentMinute = () => {
      const date = new Date(new Date() - new Date().getTimezoneOffset() * 60 * 1000);
      date.setSeconds(0, 0);
      return date.toISOString().slice(0, -1);
    };
    const downloadTextFile = (type, filename, data) => {
      const blob = new Blob([data], {type});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.download = filename;
      a.href = url;
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    };
    const prepareTrade = trade => ({
      ...trade,
      executions: trade.executions.map(execution => ({
        ...execution,
        quantity: parseFloat(execution.quantity),
        price: parseFloat(execution.price),
        fees: parseFloat(execution.fees),
      })),
      tags: trade.tags.filter(tag => tag !== ""),
    });

    const LocaleContext = createContext(null);
    const ThemeContext = createContext(null);

    const TradeTable = ({trades, editTrade, removeTrade}) => {
      const {T, C, locale} = useContext(LocaleContext);

      const entryTotal = trade => trade.executions.filter(execution => execution.action === "BUY").reduce((acc, execution) => acc + execution.quantity * execution.price + execution.fees, 0);
      const exitTotal = trade => trade.executions.filter(execution => execution.action === "SELL").reduce((acc, execution) => acc + execution.quantity * execution.price - execution.fees, 0);

      const sortedTrades = [...trades].sort((a, b) => new Date(b.executions[0].time) - new Date(a.executions[0].time));

      return h("div", {className: "trade-table"},
        h("table", null,
          h("thead", null,
            h("tr", null,
              h("th", null, T("trade-table-time-header")),
              h("th", null, T("trade-table-symbol-header")),
              h("th", null, T("trade-table-side-header")),
              h("th", null, T("trade-table-entry-total-header")),
              h("th", null, T("trade-table-exit-total-header")),
              h("th", null, T("trade-table-net-profit-loss-header")),
              h("th", null, T("trade-table-tags-header")),
              h("th", null, T("trade-table-edit-header")),
              h("th", null, T("trade-table-remove-header")),
            ),
          ),
          h("tbody", null,
            sortedTrades.map(trade => h("tr", {key: trade.id},
              h("td", null, new Date(trade.executions[0].time).toLocaleString(locale)),
              h("td", null, trade.symbol),
              h("td", null, trade.executions[0].action === "BUY" ? T("trade-table-side-long") : T("trade-table-side-short")),
              h("td", null, C(entryTotal(trade))),
              h("td", null, C(exitTotal(trade))),
              h("td", null, C(exitTotal(trade) - entryTotal(trade))),
              h("td", null, trade.tags.join(";")),
              h("td", null, h("button", {onClick: () => editTrade(trade)}, "Edit")),
              h("td", null, h("button", {onClick: () => removeTrade(trade)}, "Remove")),
            )),
          ),
        ),
      );
    };

    const TradeCharts = ({trades}) => {
      const {T, locale, C, currency} = useContext(LocaleContext);
      const {S, theme} = useContext(ThemeContext);
      const winsVersusTODChartRef = useRef(null);
      const winsVersusPriceChartRef = useRef(null);
      const equityCurveRef = useRef(null);

      useEffect(() => {
        const prices = [0, 1, 2, 5, 10, 20, 50, 100, 500, 5000, 10000, 100000, 1000000];
        const labels = [];
        const data = [];
        for (let i = 0; i < prices.length - 1; ++i) {
          const priceMin = prices[i];
          const priceMax = prices[i + 1];
          labels.push(C(priceMin) + " - " + C(priceMax));
          data.push(trades.filter(trade => trade.executions[0].price >= priceMin && trade.executions[0].price < priceMax).reduce((acc, trade) => acc + (trade.executions.reduce((acc2, execution) => acc2 + execution.quantity * execution.price * (execution.action === "BUY" ? -1 : 1) - execution.fees, 0) >= 0.0 ? 1 : -1), 0));
        }

        const chart = new Chart(winsVersusPriceChartRef.current, {
          type: "bar",
          data: {
            labels,
            datasets: [{
              label: T("trade-charts-trades-won-header"),
              data,
              borderWidth: 1,
              backgroundColor: S("accent"),
            }],
          },
          options: {
            indexAxis: "y",
            scales: {
              x: {
                min: Math.min(...data, -10),
                max: Math.max(...data, +10),
                ticks: {
                  color: S("text-primary"),
                },
                grid: {
                  color: S("text-primary"),
                },
              },
              y: {
                ticks: {
                  color: S("text-primary"),
                },
                grid: {
                  color: S("text-primary"),
                },
              },
            },
            plugins: {
              legend: {
                labels: {
                  color: S("text-primary"),
                },
              },
            },
          },
        });
        return () => chart.destroy();
      }, [trades, currency, theme]);
      useEffect(() => {
        const times = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20];
        const labels = [];
        const data = [];
        for (let i = 0; i < times.length - 1; ++i) {
          const timeMin = times[i];
          const timeMax = times[i + 1];
          labels.push(String((timeMin - 1) % 12 + 1).padStart(2, "0") + ":00 - " + String((timeMax - 1) % 12 + 1).padStart(2, "0") + ":00");
          data.push(trades.filter(trade => new Date(trade.executions[0].time).getHours() >= timeMin && new Date(trade.executions[0].time).getHours() < timeMax).reduce((acc, trade) => acc + (trade.executions.reduce((acc2, execution) => acc2 + execution.quantity * execution.price * (execution.action === "BUY" ? -1 : 1) - execution.fees, 0) >= 0.0 ? 1 : -1), 0));
        }

        const chart = new Chart(winsVersusTODChartRef.current, {
          type: "bar",
          data: {
            labels,
            datasets: [{
              label: T("trade-charts-trades-won-header"),
              data,
              borderWidth: 1,
              backgroundColor: S("accent"),
            }],
          },
          options: {
            indexAxis: "y",
            scales: {
              x: {
                min: Math.min(...data, -10),
                max: Math.max(...data, +10),
                ticks: {
                  color: S("text-primary"),
                },
                grid: {
                  color: S("text-primary"),
                },
              },
              y: {
                ticks: {
                  color: S("text-primary"),
                },
                grid: {
                  color: S("text-primary"),
                },
              },
            },
            plugins: {
              legend: {
                labels: {
                  color: S("text-primary"),
                },
              },
            },
          },
        });
        return () => chart.destroy();
      }, [trades, theme]);
      useEffect(() => {
        const labels = [];
        const data = [];
        let startDate = trades.reduce((acc, trade) => Math.min(new Date(trade.executions[0].time).valueOf(), acc), new Date().valueOf());
        let runningTotal = 0.0;
        for (const dt = new Date(startDate); dt <= new Date(); dt.setDate(dt.getDate() + 1)) {
          const end = new Date(new Date(dt).setDate(dt.getDate() + 1));
          labels.push(dt.toLocaleDateString(locale));
          const dayTrades = trades.filter(trade => new Date(trade.executions[0].time) >= dt && new Date(trade.executions[0].time) < end);
          runningTotal += dayTrades.reduce((acc, trade) => acc + trade.executions.reduce((acc2, execution) => acc2 + execution.quantity * execution.price * (execution.action === "BUY" ? -1 : 1) - execution.fees, 0.0), 0.0);
          data.push(runningTotal);
        }

        const chart = new Chart(equityCurveRef.current, {
          type: "line",
          data: {
            labels,
            datasets: [{
              label: T("trade-charts-equity-header"),
              data,
              borderWidth: 1,
              borderColor: S("accent"),
              backgroundColor: S("accent"),
              borderWidth: 2,
              pointRadius: 1,
          }],
          },
          options: {
            scales: {
              x: {
                ticks: {
                  color: S("text-primary"),
                },
                grid: {
                  color: S("text-primary"),
                },
              },
              y: {
                ticks: {
                  color: S("text-primary"),
                },
                grid: {
                  color: S("text-primary"),
                },
              },
            },
            plugins: {
              legend: {
                labels: {
                  color: S("text-primary"),
                },
              },
            },
          },
        });
        return () => chart.destroy();
      }, [trades, locale, theme, currency]);

      return h("div", {className: "trade-charts"},
        h("div", {className: "trade-charts-chart"},
          h("span", {className: "trade-charts-title"}, T("trade-charts-trades-won-relative-to-price-range-text")),
          h("canvas", {ref: winsVersusPriceChartRef}),
        ),
        h("div", {className: "trade-charts-chart"},
          h("span", {className: "trade-charts-title"}, T("trade-charts-trades-won-relative-to-time-frame-text")),
          h("canvas", {ref: winsVersusTODChartRef}),
        ),
        h("div", {className: "trade-charts-chart"},
          h("span", {className: "trade-charts-title"}, T("trade-charts-equity-curve-text")),
          h("canvas", {ref: equityCurveRef}),
        ),
      );
    };

    const TradeStats = ({trades}) => {
      const {T, C, P} = useContext(LocaleContext);

      const netProfitLosses = trades.map(trade => trade.executions.reduce((acc, execution) => acc + execution.quantity * execution.price * (execution.action === "BUY" ? -1 : 1) - execution.fees, 0));
      const wins = netProfitLosses.filter(net => net >= 0.0);
      const losses = netProfitLosses.filter(net => net < 0.0);

      return h("div", {className: "trade-stats"},
        h("span", null, `${T("trade-stats-total-profit-loss-label")} ${C(netProfitLosses.reduce((acc, net) => acc + net, 0))}`),
        h("span", null, `${T("trade-stats-total-fees-label")} ${C(trades.reduce((acc, trade) => acc + trade.executions.reduce((acc2, execution) => acc2 + execution.fees, 0), 0))}`),
        h("span", null, `${T("trade-stats-total-trades-label")} ${netProfitLosses.length}`),
        h("span", null, `${T("trade-stats-win-count-label")} ${wins.length}`),
        h("span", null, `${T("trade-stats-loss-count-label")} ${losses.length}`),
        h("span", null, `${T("trade-stats-win-percentage-label")} ${P(wins.length / (netProfitLosses.length || 1))}`),
        h("span", null, `${T("trade-stats-largest-win-label")} ${C(wins.reduce((acc, win) => Math.max(acc, win), 0))}`),
        h("span", null, `${T("trade-stats-largest-loss-label")} ${C(losses.reduce((acc, loss) => Math.min(acc, loss), 0))}`),
        h("span", null, `${T("trade-stats-average-trade-label")} ${C(netProfitLosses.reduce((acc, net) => acc + net, 0) / (netProfitLosses.length || 1))}`),
        h("span", null, `${T("trade-stats-average-win-label")} ${C(wins.reduce((acc, win) => acc + win, 0) / (wins.length || 1))}`),
        h("span", null, `${T("trade-stats-average-loss-label")} ${C(losses.reduce((acc, loss) => acc + loss, 0) / (losses.length || 1))}`),
      );
    };

    const TradeEntry = ({trade, setTrade, onSaveTrade, closeSelf}) => {
      const id = useId();
      const {T} = useContext(LocaleContext);
      const dialogRef = useRef(null);
      const symbolRef = useRef(null);

      const addExecution = () => {
        const executions = [...trade.executions];
        executions.push({
          action: executions.length > 0 && executions[executions.length - 1].action === "BUY" ? "SELL" : "BUY",
          time: executions.length > 0 ? executions[executions.length - 1].time : currentMinute(),
          quantity: executions.length > 0 ? executions[executions.length - 1].quantity : "",
          price: "",
          fees: "",
        });
        setTrade({...trade, executions});
      };
      const updateExecution = (i, value) => {
        const executions = [...trade.executions];
        Object.assign(executions[i], value);
        setTrade({...trade, executions});
      };
      const removeExecution = i => {
        const executions = [...trade.executions.slice(0, i), ...trade.executions.slice(i + 1)];
        setTrade({...trade, executions});
      };
      const onSubmit = e => {
        e.preventDefault();
        onSaveTrade(trade);
        closeSelf();
      };

      useEffect(() => {
        dialogRef.current.showModal();
        symbolRef.current.focus();
      }, []);
      useEffect(() => { if (trade.executions.length === 0) addExecution(); }, []);

      return h("dialog", {ref: dialogRef, onCancel: closeSelf},
        h("div", {className: "flex-header"},
          h("h2", null, T("trade-entry-header-text")),
          h("span", {className: "flex-grow"}),
          h("button", {onClick: closeSelf}, T("trade-entry-close-button")),
        ),
        h("form", {className: "flex-column", onSubmit},
          h("label", {htmlFor: id + "-symbol"}, T("trade-entry-symbol-label")),
          h("input", {id: id + "-symbol", ref: symbolRef, type: "text", required: true, placeholder: T("trade-entry-symbol-placeholder"), value: trade.symbol, onChange: e => setTrade({...trade, symbol: e.target.value.replace(/,/g, "").toUpperCase()})}),
          h("label", {htmlFor: id + "-tags"}, T("trade-entry-tags-label")),
          h("input", {id: id + "-tags", type: "text", placeholder: T("trade-entry-tags-placeholder"), value: trade.tags.join(";"), onChange: e => setTrade({...trade, tags: e.target.value.split(";")})}),
          trade.executions.map((execution, i) => h("div", {key: i, className: "flex-column trade-execution"},
            h("button", {type: "button", onClick: () => removeExecution(i), disabled: trade.executions.length === 1}, T("trade-entry-remove-execution-button")),
            h("button", {type: "button", onClick: () => updateExecution(i, {action: execution.action === "BUY" ? "SELL" : "BUY"})}, execution.action === "BUY" ? T("trade-entry-action-buy-button") : T("trade-entry-action-sell-button")),
            h("label", {htmlFor: id + "-time-" + i}, T("trade-entry-time-label")),
            h("input", {id: id + "-time-" + i, type: "datetime-local", required: true, step: "1", value: execution.time, onChange: e => updateExecution(i, {time: e.target.value})}),
            h("label", {htmlFor: id + "-quantity-" + i}, T("trade-entry-quantity-label")),
            h("input", {id: id + "-quantity-" + i, type: "text", required: true, value: execution.quantity, onChange: e => updateExecution(i, {quantity: e.target.value})}),
            h("label", {htmlFor: id + "-price-" + i}, T("trade-entry-price-label")),
            h("input", {id: id + "-price-" + i, type: "text", required: true, value: execution.price, onChange: e => updateExecution(i, {price: e.target.value})}),
            h("label", {htmlFor: id + "-fees-" + i}, T("trade-entry-fees-label")),
            h("input", {id: id + "-fees-" + i, type: "text", required: true, value: execution.fees, onChange: e => updateExecution(i, {fees: e.target.value})}),
            )),
          h("button", {type: "button", onClick: addExecution}, T("trade-entry-add-execution-button")),
          h("button", null, T("trade-entry-save-button")),
        ),
      );
    };

    const TradeImportExport = ({trades, closeSelf}) => {
      const id = useId();
      const {T} = useContext(LocaleContext);
      const [CSVType, setCSVType] = useState("stonkla");
      const dialogRef = useRef(null);
      const fileInputRef = useRef(null);

      const importCSV = e => {
        e.preventDefault();
        const reader = new FileReader();
        reader.onload = e => {
          const text = e.target.result;
          const lines = text.split("\n").filter(line => line !== "");
          const headings = lines[0].split(",");
          switch (CSVType) {
            case "stonkla": {
              const data = lines.slice(1).map(line => line.split(","));
              const newTrades = [];
              let rowIndex = 0;
              while (rowIndex < data.length) {
                const [startId, startSymbol] = data[rowIndex].slice(0, 2);
                const executions = [];
                const tags = data[rowIndex][7].split(";");
                while (rowIndex < data.length) {
                  const [id, symbol, action, time, quantity, price, fees, tags] = data[rowIndex];
                  if (id !== startId) break;
                  executions.push({action, time, quantity, price, fees});
                  rowIndex += 1;
                }
                executions.sort((a, b) => new Date(a.time) - new Date(b.time));
                newTrades.push(prepareTrade({symbol: startSymbol, executions, tags}));
              }
              DB.bulkAdd("trades", newTrades);
              break;
            }
            case "lightspeed": {
              const data = lines.slice(1).map(line => line.split(","));
              const newTrades = [];
              let rowIndex = 0;
              while (rowIndex < data.length) {
                const obj = Object.fromEntries(headings.map((heading, i) => [heading, data[rowIndex][i]]));
                const get = key => obj[`"${key}"`].slice(1, -1).trim();
                const startSymbol = get("Symbol");
                const executions = [];
                const tags = ["Lightspeed"];
                while (rowIndex < data.length) {
                  const obj = Object.fromEntries(headings.map((heading, i) => [heading, data[rowIndex][i]]));
                  const get = key => obj[`"${key}"`].slice(1, -1).trim();
                  const [symbol, side, quantity, price, time] = [get("Symbol"), get("Side"), get("Qty"), get("Price"), get("Raw Exec. Time")];
                  if (symbol !== startSymbol) break;
                  executions.push({action: side === "B" ? "BUY" : "SELL", time: toLocalTime(new Date(time)), quantity: Math.abs(quantity), price, fees: parseFloat(get("Commission Amount")) + parseFloat(get("Fee1")) + parseFloat(get("Fee2")) + parseFloat(get("Fee3")) + parseFloat(get("Fee4")) + parseFloat(get("FeeMF")) + parseFloat(get("FeeSEC")) + parseFloat(get("FeeStamp")) + parseFloat(get("FeeTAF"))});
                  rowIndex += 1;
                }
                newTrades.push(prepareTrade({symbol: startSymbol, executions, tags}));
              }
              DB.bulkAdd("trades", newTrades);
              break;
            }
            case "webull": {
              const data = lines.slice(1).map(line => line.split(",")).filter(line => line[3] === "Filled");
              const newTrades = [];
              let rowIndex = 0;
              while (rowIndex < data.length) {
                const startSymbol = data[rowIndex][1];
                const executions = [];
                const tags = ["Webull"];
                while (rowIndex < data.length) {
                  const [name, symbol, action, filled, quantity, quantity2, price, avgPrice, tif, time, time2] = data[rowIndex];
                  if (symbol !== startSymbol) break;
                  executions.push({action: action === "Buy" ? "BUY" : "SELL", time: toLocalTime(new Date(time.slice(0, 24))), quantity, price: avgPrice, fees: action === "Sell" ? 0.02 : 0.0});
                  rowIndex += 1;
                }
                executions.reverse();
                newTrades.push(prepareTrade({symbol: startSymbol, executions, tags}));
              }
              newTrades.reverse();
              DB.bulkAdd("trades", newTrades);
              break;
            }
            default: {
              console.error("unknown CSV type selected", CSVType);
              break;
            }
          }
        };
        reader.readAsText(fileInputRef.current.files[0]);
      };
      const exportCSV = () => {
        let result = "id,symbol,action,time,quantity,price,fees,tags\n";
        for (const trade of trades) {
          for (const execution of trade.executions) {
            result += trade.id + ",";
            result += trade.symbol + ",";
            result += execution.action + ",";
            result += execution.time + ",";
            result += execution.quantity + ",";
            result += execution.price + ",";
            result += execution.fees + ",";
            result += trade.tags.join(";") + "\n";
          }
        }
        downloadTextFile("text/csv", "trades.csv", result);
      };

      useEffect(() => dialogRef.current.showModal(), []);

      return h("dialog", {ref: dialogRef, onCancel: closeSelf},
        h("div", {className: "flex-header"},
          h("h2", null, T("trade-import-export-header-text")),
          h("span", {className: "flex-grow"}),
          h("button", {onClick: closeSelf}, T("trade-import-export-close-button")),
        ),
        h("form", {className: "flex-column", onSubmit: importCSV},
          h("label", {htmlFor: id + "-csv-type"}, T("trade-import-export-csv-type-label")),
          h("select", {id: id + "-csv-type", defaultValue: CSVType, onChange: e => setCSVType(e.target.value)},
             h("option", {value: "stonkla"}, "Stonkla"),
             h("option", {value: "lightspeed"}, "Lightspeed"),
             h("option", {value: "webull"}, "Webull"),
          ),
          h("label", {htmlFor: id + "-csv-file"}, T("trade-import-export-csv-file-label")),
          h("input", {ref: fileInputRef, id: id + "-csv-file", type: "file", required: true}),
          h("button", null, T("trade-import-export-import-from-csv-button")),
        ),
        h("div", {className: "flex-column"},
          h("button", {onClick: exportCSV}, T("trade-import-export-export-to-csv-button")),
        ),
      );
    };

    const AppSettings = ({closeSelf}) => {
      const id = useId();
      const {T, locale, setLocale, currency, setCurrency} = useContext(LocaleContext);
      const {theme, setTheme} = useContext(ThemeContext);
      const dialogRef = useRef(null);

      useEffect(() => dialogRef.current.showModal(), []);

      return h("dialog", {ref: dialogRef, onCancel: closeSelf},
        h("div", {className: "flex-header"},
          h("h2", null, T("app-settings-header-text")),
          h("span", {className: "flex-grow"}),
          h("button", {onClick: closeSelf}, T("app-settings-close-button")),
        ),
        h("div", {className: "flex-column"},
          h("label", {htmlFor: id + "-locale"}, T("app-settings-locale-label")),
          h("select", {id: id + "-locale", defaultValue: locale, onChange: e => setLocale(e.target.value)},
            Object.keys(TRANSLATIONS).map(l => h("option", {key: l, value: l}, TRANSLATIONS[l]["translation-name"])),
          ),
          h("label", {htmlFor: id + "-theme"}, T("app-settings-theme-label")),
          h("select", {id: id + "-theme", defaultValue: theme, onChange: e => setTheme(e.target.value)},
            Object.keys(THEMES).map(t => h("option", {key: t, value: t}, t)),
          ),
          h("label", {htmlFor: id + "-currency"}, T("app-settings-currency-label")),
          h("select", {id: id + "-currency", defaultValue: currency, onChange: e => setCurrency(e.target.value)},
            ["USD", "CAD", "GBP", "EUR", "JPY"].map(c => h("option", {key: c, value: c}, c)),
          ),
          h("button", {className: "app-settings-remove-all-trades-button", onClick: () => confirm(T("app-settings-remove-all-trades-confirm")) && DB.clear("trades")}, T("app-settings-remove-all-trades-button")),
        ),
      );
    };

    const App = () => {
      const defaultLocale = localStorage.getItem("locale") ?? navigator.language.slice(0, 2);
      const defaultTheme = localStorage.getItem("theme") ?? "gray-matter";

      const [locale, setLocale] = useState(defaultLocale in TRANSLATIONS ? defaultLocale : Object.keys(TRANSLATIONS)[0]);
      const [theme, setTheme] = useState(defaultTheme in THEMES ? defaultTheme : Object.keys(THEMES)[0]);
      const [currency, setCurrency] = useState(localStorage.getItem("currency") ?? "USD");
      const [showAppSettings, setShowAppSettings] = useState(false);
      const [showTradeImportExport, setShowTradeImportExport] = useState(false);
      const [showTradeEntry, setShowTradeEntry] = useState(false);
      const [editingTrade, setEditingTrade] = useState(null);
      const [onEditingTradeSave, setOnEditingTradeSave] = useState(null);
      const [trades, setTrades] = useState([]);

      const T = key => TRANSLATIONS[locale][key] ?? console.error(`Key "${key}" not found in locale "${locale}".`);
      const S = key => THEMES[theme][key] ?? console.error(`Key "${key}" not found in theme "${theme}".`);
      const C = amount => new Intl.NumberFormat(locale, {style: "currency", currency}).format(amount);
      const P = amount => new Intl.NumberFormat(locale, {style: "percent", maximumFractionDigits: 2}).format(amount);

      const addTrade = () => {
        setEditingTrade({
          symbol: "",
          executions: [],
          tags: [],
        });
        setOnEditingTradeSave(() => trade => DB.add("trades", prepareTrade(trade)));
        setShowTradeEntry(true);
      };
      const editTrade = trade => {
        setEditingTrade(structuredClone(trade));
        setOnEditingTradeSave(() => trade => DB.put("trades", prepareTrade(trade)));
        setShowTradeEntry(true);
      };
      const removeTrade = trade => DB.delete("trades", trade.id);

      useEffect(() => localStorage.setItem("locale", locale), [locale]);
      useEffect(() => localStorage.setItem("theme", theme), [theme]);
      useEffect(() => localStorage.setItem("currency", currency), [currency]);
      useEffect(() => {
        const handler = () => DB.getAll("trades").then(request => (request.onsuccess = e => setTrades(e.target.result)));
        handler();
        document.addEventListener("ondbchange", handler);
        return () => document.removeEventListener("ondbchange", handler);
      }, []);

      return h(LocaleContext.Provider, {value: {T, C, P, locale, setLocale, currency, setCurrency}},
        h(ThemeContext.Provider, {value: {S, theme, setTheme}},
          h("style", null, `
            @import url('https://fonts.googleapis.com/css2?family=Inter:opsz@14..32&display=swap');

            body, dialog {
              font-family: "Inter", sans-serif;
              background-color: ${S("background-primary")};
              color: ${S("text-primary")};
            }

            a {
              color: ${S("accent")};
            }

            dialog {
              border-radius: 10px;
            }

            table {
              width: fit-content;
              margin: 0 auto;
              text-wrap: nowrap;
              border-collapse: collapse;
            }

            thead {
              border-bottom: 2px solid;
            }

            th {
              text-align: start;
            }

            th, td {
              border: 1px solid;
              padding: 5px;
            }

            footer {
              margin: 10px;
              text-align: center;
            }

            .app-settings-remove-all-trades-button {
              color: red;
            }

            .trade-table {
              overflow: auto;
            }

            .trade-charts {
              display: flex;
              justify-content: center;
              flex-wrap: wrap;
            }

            .trade-charts-chart {
              background-color: ${S("background-secondary")};
              padding: 10px;
              margin: 10px;
              border-radius: 10px;
              min-width: min(90%, 700px);
            }

            .trade-stats {
              display: flex;
              flex-wrap: wrap;
              justify-content: center;
            }

            .trade-stats * {
              background-color: ${S("background-secondary")};
              padding: 15px;
              margin: 10px;
              border-radius: 15px;
              border: 2px solid ${S("text-primary")};
            }

            .flex-header {
              display: flex;
              align-items: center;
            }

            .flex-header *:not(:last-child) {
              margin-right: 5px;
            }

            .flex-grow {
              flex-grow: 1;
            }

            .flex-column {
              display: flex;
              flex-direction: column;
            }

            .trade-execution {
              background-color: ${S("background-secondary")};
              margin: 10px 0;
              padding: 10px;
              border-radius: 10px;
            }
          `),
          h("div", {className: "flex-header"},
            h("h1", null, "Stonkla"),
            h("span", {className: "flex-grow"}),
            h("button", {onClick: addTrade}, T("app-add-trade-button")),
            h("button", {onClick: () => setShowTradeImportExport(true)}, T("app-import-export-button")),
            h("button", {onClick: () => setShowAppSettings(true)}, T("app-open-settings-button")),
          ),
          showAppSettings && h(AppSettings, {closeSelf: () => setShowAppSettings(false)}),
          showTradeImportExport && h(TradeImportExport, {trades, closeSelf: () => setShowTradeImportExport(false)}),
          showTradeEntry && h(TradeEntry, {trade: editingTrade, setTrade: setEditingTrade, onSaveTrade: onEditingTradeSave, closeSelf: () => setShowTradeEntry(false)}),
          h(TradeStats, {trades}),
          h(TradeCharts, {trades}),
          h(TradeTable, {trades, editTrade, removeTrade}),
          h("footer", null,
            "Made with ❤️ by Dfra",
            h("br"),
            h("a", {href: "https://github.com/sponsors/dawsonfrakes", target: "_blank"}, "Sponsor on GitHub"),
          ),
        ),
      );
    };

    ReactDOMClient.createRoot(document.body).render(h(App));
  </script>
</body>
</html>
