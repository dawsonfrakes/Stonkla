<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stonkla</title>
</head>
<body>
  <script>
    let context = null;
    const createTextElement = text => ({type: "TEXT_ELEMENT", props: {nodeValue: text, children: []}});
    const createElement = (type, props, ...children) =>
      ({type, props: {...props, children: children.flat().map(child => typeof child === "string" || typeof child === "number" ? createTextElement(child) : child)}});
    const h = createElement;
    const useState = defaultValue => {
      if (context.index === context.hooks.length) context.hooks.push({value: typeof defaultValue === "function" ? defaultValue() : defaultValue});
      const [hook, update] = [context.hooks[context.index++], context.update];
      const setHook = newValue => { hook.value = typeof newValue === "function" ? newValue() : newValue; update(); };
      return [hook.value, setHook];
    };
    const useEffect = (callback, deps) => {
      if (context.index === context.hooks.length) context.hooks.push({value: deps, callback, cleanup: null});
      const hook = context.hooks[context.index++];
      if (!hook.value || hook.value.some((dep, i) => dep != deps[i])) {
        hook.value = deps;
        hook.callback = callback;
      }
    };
    const render = (vnode, dom) => {
      const vlist = [].concat(vnode).map(v => v ? v : createTextElement(""))
      const ids = {};
      const hooks = dom.hooks ?? {};
      dom.hooks = {};
      vlist.forEach((v, i) => {
        while (typeof v.type === "function") {
          const key = v.props.key ?? (v.type + (ids[v.type] = (ids[v.type] ?? 1) + 1));
          context = {hooks: hooks[key] ?? [], index: 0, update: () => render(vlist, dom)};
          v = v.type(v.props);
          dom.hooks[key] = context.hooks;
        }
        if (v.type === "style") {
          const style = document.head.getElementsByTagName("style")[0] ?? document.head.appendChild(document.createElement("style"));
          style.textContent = v.props.children.reduce((acc, child) => acc + child.props.nodeValue, "");
          v = createTextElement("");
        }
        let node = dom.childNodes[i];
        if (!node || node._type !== v.type) node = dom.insertBefore(v.type === "TEXT_ELEMENT" ? document.createTextNode("") : document.createElement(v.type), node ?? null);
        node._type = v.type;
        Object.keys(v.props).forEach(prop => {
          if (prop === "children") return;
          if (prop.startsWith("on")) {
            node[prop.toLowerCase()] = v.props[prop];
            return;
          }
          node[prop] = v.props[prop];
        });
        if (node._type === "select" && node.defaultValue) {
          v.props.children = v.props.children.map(child => child.type === "option" && child.props.value === node.defaultValue ? ({...child, props: {...child.props, selected: true}}) : child);
          node.defaultValue = undefined;
        }
        render(v.props.children, node);
      });
      Object.values(dom.hooks).forEach(hooks => hooks.forEach(hook => setTimeout(() => { hook.callback && ((hook.cleanup = hook.callback()), hook.callback = null); }, 0)));
      Object.keys(hooks).filter(key => !dom.hooks[key]).forEach(key => hooks[key].forEach(hook => hook.cleanup && hook.cleanup()));
      for (let child; (child = dom.childNodes[vlist.length]); )
        render([], dom.removeChild(child));
    };

    const DB = (() => {
      const ondbchange = new CustomEvent("ondbchange");
      const inner = new Promise((resolve, reject) => {
        const request = indexedDB.open("stonkla", 1);
        request.onsuccess = e => resolve(e.target.result);
        request.onerror = e => reject(e.target.error);
        request.onupgradeneeded = e => {
          const db = e.target.result;
          if (db.version >= 1) {
            const store = db.createObjectStore("trades", {keyPath: "id", autoIncrement: true});
            store.createIndex("symbol", "symbol");
            store.createIndex("executions", "executions");
            store.createIndex("tags", "tags");
          }
        };
      });
      return {
        add: (store, value) => inner.then(db => db.transaction(store, "readwrite").objectStore(store).add(value)).then(() => document.dispatchEvent(ondbchange)),
        bulkAdd: (store, values) => inner.then(db => { const tx = db.transaction(store, "readwrite").objectStore(store); values.forEach(value => tx.add(value)); return tx; }).then(() => document.dispatchEvent(ondbchange)),
        put: (store, value) => inner.then(db => db.transaction(store, "readwrite").objectStore(store).put(value)).then(() => document.dispatchEvent(ondbchange)),
        delete: (store, id) => inner.then(db => db.transaction(store, "readwrite").objectStore(store).delete(id)).then(() => document.dispatchEvent(ondbchange)),
        clear: store => inner.then(db => db.transaction(store, "readwrite").objectStore(store).clear()).then(() => document.dispatchEvent(ondbchange)),
        get: (store, id) => inner.then(db => db.transaction(store).objectStore(store).get(id)),
        getAll: store => inner.then(db => db.transaction(store).objectStore(store).getAll()),
      };
    })();

    const TRANSLATIONS = {
      "en": {
        "translation-name": "English",
        "app-add-trade-button": "Add Trade",
        "app-import-export-button": "Import/Export",
        "app-open-settings-button": "Settings",
        "app-made-with-love-text": "Made with ❤️ by Dfra",
        "app-sponsor-on-github-link": "Sponsor on GitHub",
        "app-settings-header": "Settings",
        "app-settings-close-button": "Close",
        "app-settings-locale-label": "Locale:",
        "app-settings-theme-label": "Theme:",
        "app-settings-currency-label": "Currency:",
        "app-settings-remove-all-trades-button": "Remove All Trades",
        "app-settings-remove-all-trades-confirm": "Are you sure you want to remove all trades?",
        "trade-import-export-header": "Import/Export",
        "trade-import-export-close-button": "Close",
        "trade-import-export-import-from-csv": "Import from CSV",
        "trade-import-export-export-to-csv-button": "Export to CSV",
        "trade-entry-header": "Trade Entry",
        "trade-entry-close-button": "Close",
        "trade-entry-symbol-label": "Symbol:",
        "trade-entry-symbol-placeholder": "Symbol",
        "trade-entry-tags-label": "Tags:",
        "trade-entry-tags-placeholder": "Tags",
        "trade-entry-add-execution-button": "Add Execution",
        "trade-entry-save-button": "Save",
        "trade-entry-remove-execution-button": "Remove",
        "trade-entry-action-buy-button": "BUY",
        "trade-entry-action-sell-button": "SELL",
        "trade-entry-time-label": "Time:",
        "trade-entry-quantity-label": "Quantity:",
        "trade-entry-quantity-placeholder": "Quantity",
        "trade-entry-price-label": "Price:",
        "trade-entry-price-placeholder": "Price",
        "trade-entry-fees-label": "Fees:",
        "trade-entry-fees-placeholder": "Fees",
        "trade-stats-total-profit-loss": "Total Profit/Loss",
        "trade-stats-total-fees": "Total Fees & Commissions",
        "trade-stats-total-trades": "Total Trades",
        "trade-stats-total-wins": "Total Wins",
        "trade-stats-total-losses": "Total Losses",
        "trade-stats-win-percentage": "Win Percentage",
        "trade-stats-largest-win": "Largest Win",
        "trade-stats-largest-loss": "Largest Loss",
        "trade-stats-average-trade": "Average Trade",
        "trade-stats-average-win": "Average Win",
        "trade-stats-average-loss": "Average Loss",
        "trade-table-time-header": "Time",
        "trade-table-symbol-header": "Symbol",
        "trade-table-entry-total-header": "Entry Total",
        "trade-table-exit-total-header": "Exit Total",
        "trade-table-net-profit-loss-header": "Net P/L",
        "trade-table-tags-header": "Tags",
        "trade-table-edit-header": "Edit",
        "trade-table-remove-header": "Remove",
        "trade-table-edit-button": "Edit",
        "trade-table-remove-button": "Remove",
      },
    };

    const THEMES = {
      "suisei-light": {
        "background-primary": "#c4b59d",
        "background-secondary": "#b19d7d",
        "text-primary": "#242114",
        "text-secondary": "#500500",
        "accent": "#0167be",
      },
      "suisei-dark": {
        "background-primary": "#3b4a62",
        "background-secondary": "#4e6282",
        "text-primary": "#dbdeeb",
        "text-secondary": "#affaff",
        "accent": "#fe9841",
      },
    };

    const currentMinute = () => {
      const date = new Date(new Date() - new Date().getTimezoneOffset() * 60 * 1000);
      date.setSeconds(0, 0);
      return date.toISOString().slice(0, -1);
    };
    const downloadTextFile = (type, name, text) => {
      const blob = new Blob([text], {type})
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      [a.download, a.href] = [name, url];
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    };
    const prepareTrade = trade => {
      return {
        ...trade,
        executions: trade.executions.map(execution => ({
          ...execution,
          time: new Date(execution.time).toISOString().slice(0, -1),
          quantity: parseFloat(execution.quantity),
          price: parseFloat(execution.price),
          fees: parseFloat(execution.fees),
        })),
        tags: trade.tags.filter(tag => tag !== ""),
      }
    };

    const TradeTable = ({T, locale, C, trades, setTrades, editTrade, removeTrade}) => {
      const entryTotal = trade => trade.executions.filter(execution => execution.action === "BUY").reduce((acc, execution) => acc + execution.quantity * execution.price + execution.fees, 0);
      const exitTotal = trade => trade.executions.filter(execution => execution.action === "SELL").reduce((acc, execution) => acc + execution.quantity * execution.price - execution.fees, 0);

      const sortedTrades = [...trades].sort((a, b) => new Date(a.executions[0].time) - new Date(b.executions[0].time));

      return (
        h("div", {className: "trade-table"},
          h("table", null,
            h("thead", null,
              h("tr", null,
                h("th", null, T("trade-table-time-header")),
                h("th", null, T("trade-table-symbol-header")),
                h("th", null, T("trade-table-entry-total-header")),
                h("th", null, T("trade-table-exit-total-header")),
                h("th", null, T("trade-table-net-profit-loss-header")),
                h("th", null, T("trade-table-tags-header")),
                h("th", null, T("trade-table-edit-header")),
                h("th", null, T("trade-table-remove-header")),
              ),
            ),
            h("tbody", null,
              sortedTrades.map(trade => h("tr", {key: trade.id},
                h("td", null, new Date(trade.executions[0].time).toLocaleString(locale)),
                h("td", null, trade.symbol),
                h("td", null, C(entryTotal(trade))),
                h("td", null, C(exitTotal(trade))),
                h("td", null, C(exitTotal(trade) - entryTotal(trade))),
                h("td", null, trade.tags.join(";")),
                h("td", null, h("button", {onClick: () => editTrade(trade)}, T("trade-table-edit-button"))),
                h("td", null, h("button", {onClick: () => removeTrade(trade)}, T("trade-table-remove-button"))),
              )),
            ),
          ),
        )
      );
    };

    const TradeStats = ({T, C, P, trades}) => {
      const netProfitLosses = trades.map(trade => trade.executions.reduce((acc, execution) => acc + (execution.quantity * execution.price) * (execution.action === "BUY" ? -1 : 1) - execution.fees, 0.0));
      const wins = netProfitLosses.filter(net => net >= 0.0);
      const losses = netProfitLosses.filter(net => net < 0.0);

      return (
        h("div", {className: "trade-stats"},
          h("span", null, `${T("trade-stats-total-profit-loss")}: ${C(netProfitLosses.reduce((acc, net) => acc + net, 0.0))}`),
          h("span", null, `${T("trade-stats-total-fees")}: ${C(trades.reduce((acc, trade) => acc + trade.executions.reduce((acc2, execution) => (acc2 + execution.fees), 0.0), 0.0))}`),
          h("span", null, `${T("trade-stats-total-trades")}: ${wins.length + losses.length}`),
          h("span", null, `${T("trade-stats-total-wins")}: ${wins.length}`),
          h("span", null, `${T("trade-stats-total-losses")}: ${losses.length}`),
          h("span", null, `${T("trade-stats-win-percentage")}: ${P(wins.length / ((wins.length + losses.length) || 1))}`),
          h("span", null, `${T("trade-stats-largest-win")}: ${C(wins.reduce((acc, win) => Math.max(acc, win), 0.0))}`),
          h("span", null, `${T("trade-stats-largest-loss")}: ${C(losses.reduce((acc, loss) => Math.min(acc, loss), 0.0))}`),
          h("span", null, `${T("trade-stats-average-trade")}: ${C(netProfitLosses.reduce((acc, net) => acc + net, 0.0) / (netProfitLosses.length || 1))}`),
          h("span", null, `${T("trade-stats-average-win")}: ${C(wins.reduce((acc, win) => acc + win, 0.0) / (wins.length || 1))}`),
          h("span", null, `${T("trade-stats-average-loss")}: ${C(losses.reduce((acc, loss) => acc + loss, 0.0) / (losses.length || 1))}`),
        )
      );
    };

    const TradeEntry = ({T, trade, setTrade, onSaveTrade, closeSelf}) => {
      const addExecution = () => {
        const executions = [...trade.executions];
        executions.push({
          action: executions.length > 0 && executions[executions.length - 1].action === "BUY" ? "SELL" : "BUY",
          time: executions.length > 0 ? executions[executions.length - 1].time : currentMinute(),
          quantity: "",
          price: "",
          fees: "0.00",
        });
        setTrade({...trade, executions});
      };
      const updateExecution = (i, value) => {
        const executions = [...trade.executions];
        Object.assign(executions[i], value);
        setTrade({...trade, executions});
      };
      const removeExecution = i => {
        const executions = [...trade.executions.slice(0, i), ...trade.executions.slice(i + 1)];
        setTrade({...trade, executions});
      };
      const onSubmit = e => {
        e.preventDefault();
        onSaveTrade(trade);
        closeSelf();
      };

      useEffect(() => {
        document.getElementById("trade-entry-dialog").showModal();
        return () => document.getElementById("trade-entry-dialog").close();
      }, []);
      useEffect(() => { if (trade.executions.length === 0) addExecution(); }, []);

      return (
        h("dialog", {id: "trade-entry-dialog", onCancel: closeSelf, onClose: closeSelf},
          h("h2", null, T("trade-entry-header")),
          h("button", {onClick: closeSelf}, T("trade-entry-close-button")),
          h("form", {onSubmit},
            h("label", {htmlFor: "trade-entry-symbol-input"}, T("trade-entry-symbol-label")),
            h("input", {id: "trade-entry-symbol-input", type: "text", required: true, placeholder: T("trade-entry-symbol-placeholder"), value: trade.symbol, onInput: e => setTrade({...trade, symbol: e.target.value.toUpperCase()})}),
            h("label", {htmlFor: "trade-entry-tags-input"}, T("trade-entry-tags-label")),
            h("input", {id: "trade-entry-tags-input", type: "text", placeholder: T("trade-entry-tags-placeholder"), value: trade.tags.join(";"), onInput: e => setTrade({...trade, tags: e.target.value.replace(/,/g, "").split(";")})}),
            trade.executions.map((execution, i) => h("div", null,
              h("button", {type: "button", onClick: () => removeExecution(i), disabled: trade.executions.length === 1}, T("trade-entry-remove-execution-button")),
              h("button", {type: "button", onClick: () => updateExecution(i, {...execution, action: execution.action === "BUY" ? "SELL" : "BUY"})}, execution.action === "BUY" ? T("trade-entry-action-buy-button") : T("trade-entry-action-sell-button")),
              h("label", {htmlFor: "trade-entry-time-input" + i}, T("trade-entry-time-label")),
              h("input", {id: "trade-entry-time-input" + i, type: "datetime-local", required: true, step: "1", value: execution.time, onInput: e => updateExecution(i, {time: e.target.value})}),
              h("label", {htmlFor: "trade-entry-quantity-input" + i}, T("trade-entry-quantity-label")),
              h("input", {id: "trade-entry-quantity-input" + i, type: "number", required: true, min: "0", step: "0.00001", placeholder: T("trade-entry-quantity-placeholder"), value: execution.quantity, onInput: e => updateExecution(i, {quantity: e.target.value})}),
              h("label", {htmlFor: "trade-entry-price-input" + i}, T("trade-entry-price-label")),
              h("input", {id: "trade-entry-price-input" + i, type: "number", required: true, min: "0", step: "0.00001", placeholder: T("trade-entry-price-placeholder"), value: execution.price, onInput: e => updateExecution(i, {price: e.target.value})}),
              h("label", {htmlFor: "trade-entry-fees-input" + i}, T("trade-entry-fees-label")),
              h("input", {id: "trade-entry-fees-input" + i, type: "number", required: true, step: "0.00001", placeholder: T("trade-entry-fees-placeholder"), value: execution.fees, onInput: e => updateExecution(i, {fees: e.target.value})}),
            )),
            h("button", {type: "button", onClick: addExecution}, T("trade-entry-add-execution-button")),
            h("button", null, T("trade-entry-save-button")),
          ),
        )
      );
    };

    const TradeImportExport = ({T, trades, closeSelf}) => {
      const [importType, setImportType] = useState("stonkla");

      const importCSV = e => {
        e.preventDefault();
        const files = document.getElementById("trade-import-export-files").files;
        const reader = new FileReader();
        reader.onload = e => {
          const lines = e.target.result.split("\n").filter(line => line !== "");
          const headers = lines[0].split(",");
          const rows = lines.slice(1).map(line => line.split(",")).map(values => Object.fromEntries(values.map((value, i) => [headers[i], value])));
          switch (importType) {
            case "stonkla": {
              const newTrades = [];
              let rowIndex = 0;
              while (rowIndex < rows.length) {
                const [startId, symbol] = [rows[rowIndex].id, rows[rowIndex].symbol];
                const executions = [];
                const tags = rows[rowIndex].tags.split(";");
                while (rowIndex < rows.length) {
                  const {id, action, time, quantity, price, fees} = rows[rowIndex];
                  if (id !== startId) break;
                  executions.push({action, time, quantity, price, fees});
                  rowIndex += 1;
                }
                newTrades.push(prepareTrade({symbol, executions, tags}));
              }
              DB.bulkAdd("trades", newTrades);
              break;
            }
            case "lightspeed": {
              const newTrades = [];
              let rowIndex = 0;
              while (rowIndex < rows.length) {
                const get = key => rows[rowIndex][`"${key}"`].slice(1, -1).trim();
                const startSymbol = get("Symbol");
                const executions = [];
                const tags = ["Lightspeed"];
                while (rowIndex < rows.length) {
                  const symbol = get("Symbol");
                  const action = get("Side") === "B" ? "BUY" : "SELL";
                  const time = get("Raw Exec. Time");
                  const quantity = Math.abs(get("Qty"));
                  const price = get("Price");
                  const fees = parseFloat(get("Commission Amount")) + parseFloat(get("Fee1")) + parseFloat(get("Fee2")) + parseFloat(get("Fee3")) + parseFloat(get("Fee4")) + parseFloat(get("FeeMF")) + parseFloat(get("FeeSEC")) + parseFloat(get("FeeStamp")) + parseFloat(get("FeeTAF"));
                  if (symbol != startSymbol) break;
                  executions.push({action, time, quantity, price, fees});
                  rowIndex += 1;
                }
                newTrades.push(prepareTrade({symbol: startSymbol, executions, tags}));
              }
              DB.bulkAdd("trades", newTrades);
              break;
            }
            case "webull": {
              const filteredRows = rows.filter(row => row.Status === "Filled");
              const newTrades = [];
              let rowIndex = 0;
              while (rowIndex < filteredRows.length) {
                const startSymbol = filteredRows[rowIndex].Symbol;
                const executions = [];
                const tags = ["Webull"];
                while (rowIndex < filteredRows.length) {
                  const symbol = filteredRows[rowIndex].Symbol;
                  const action = filteredRows[rowIndex].Side === "Buy" ? "BUY" : "SELL";
                  const time = filteredRows[rowIndex]["Placed Time"];
                  const quantity = filteredRows[rowIndex].Filled;
                  const price = filteredRows[rowIndex]["Avg Price"];
                  const fees = filteredRows[rowIndex].Side === "Buy" ? 0 : 0.02;
                  if (symbol != startSymbol) break;
                  executions.push({action, time, quantity, price, fees});
                  rowIndex += 1;
                }
                newTrades.push(prepareTrade({symbol: startSymbol, executions, tags}));
              }
              DB.bulkAdd("trades", newTrades);
              break;
            }
            default: {
              console.error(`Import type ${importType} not implemented.`);
              break;
            }
          }
        };
        reader.readAsText(files[0]);
      };
      const exportCSV = () => {
        let result = "id,symbol,action,time,quantity,price,fees,tags\n";
        for (const trade of trades) {
          for (const execution of trade.executions) {
            result += trade.id + ",";
            result += trade.symbol + ",";
            result += execution.action + ",";
            result += execution.time + ",";
            result += execution.quantity + ",";
            result += execution.price + ",";
            result += execution.fees + ",";
            result += trade.tags.join(";") + "\n";
          }
        }
        downloadTextFile("text/csv", "trades.csv", result);
      };

      useEffect(() => {
        document.getElementById("trade-import-export-dialog").showModal();
        return () => document.getElementById("trade-import-export-dialog").close();
      }, []);

      return (
        h("dialog", {id: "trade-import-export-dialog", onCancel: closeSelf, onClose: closeSelf},
          h("h2", null, T("trade-import-export-header")),
          h("button", {onClick: closeSelf}, T("trade-import-export-close-button")),
          h("form", {onSubmit: importCSV},
            h("select", {defaultValue: importType, onChange: e => setImportType(e.target.value)},
              h("option", {value: "stonkla"}, "Stonkla"),
              h("option", {value: "lightspeed"}, "Lightspeed"),
              h("option", {value: "webull"}, "Webull"),
            ),
            h("input", {id: "trade-import-export-files", type: "file", required: true}),
            h("button", null, T("trade-import-export-import-from-csv")),
          ),
          h("button", {onClick: exportCSV}, T("trade-import-export-export-to-csv-button")),
        )
      );
    };

    const AppSettings = ({T, locale, setLocale, theme, setTheme, currency, setCurrency, closeSelf}) => {
      useEffect(() => {
        document.getElementById("app-settings-dialog").showModal();
        return () => document.getElementById("app-settings-dialog").close();
      }, []);

      return (
        h("dialog", {id: "app-settings-dialog", onCancel: closeSelf, onClose: closeSelf},
          h("h2", null, T("app-settings-header")),
          h("button", {onClick: closeSelf}, T("app-settings-close-button")),
          h("label", {htmlFor: "app-settings-locale-select"}, T("app-settings-locale-label")),
          h("select", {id: "app-settings-locale-select", defaultValue: locale, onChange: e => setLocale(e.target.value)},
            Object.keys(TRANSLATIONS).map(locale => h("option", {key: locale, value: locale}, TRANSLATIONS[locale]["translation-name"])),
          ),
          h("label", {htmlFor: "app-settings-theme-select"}, T("app-settings-theme-label")),
          h("select", {id: "app-settings-theme-select", defaultValue: theme, onChange: e => setTheme(e.target.value)},
            Object.keys(THEMES).map(theme => h("option", {key: theme, value: theme}, theme)),
          ),
          h("label", {htmlFor: "app-settings-currency-select"}, T("app-settings-currency-label")),
          h("select", {id: "app-settings-currency-select", defaultValue: currency, onChange: e => setCurrency(e.target.value)},
            ["USD", "GBP", "EUR", "JPY", "CAD"].map(currency => h("option", {key: currency, value: currency}, currency)),
          ),
          h("button", {style: "color: red", onClick: () => confirm(T("app-settings-remove-all-trades-confirm")) && DB.clear("trades")}, T("app-settings-remove-all-trades-button")),
        )
      );
    };

    const App = () => {
      const defaultLocale = localStorage.getItem("locale") ?? navigator.language.slice(0, 2);
      const defaultTheme = localStorage.getItem("theme") ?? "suisei-light";

      const [locale, setLocale] = useState(defaultLocale in TRANSLATIONS ? defaultLocale : Object.keys(TRANSLATIONS)[0]);
      const [theme, setTheme] = useState(defaultTheme in THEMES ? defaultTheme : Object.keys(THEMES)[0]);
      const [currency, setCurrency] = useState(localStorage.getItem("currency") ?? "USD");
      const [showAppSettings, setShowAppSettings] = useState(false);
      const [showTradeEntry, setShowTradeEntry] = useState(false);
      const [showTradeImportExport, setShowTradeImportExport] = useState(false);
      const [editingTrade, setEditingTrade] = useState(null);
      const [onSaveTrade, setOnSaveTrade] = useState(null);
      const [trades, setTrades] = useState([]);

      const T = key => TRANSLATIONS[locale][key] ?? console.error(`Key "${key}" not found in locale "${locale}".`);
      const S = key => THEMES[theme][key] ?? console.error(`Key "${key}" not found in theme "${theme}".`);
      const C = amount => new Intl.NumberFormat(locale, {style: "currency", currency}).format(amount);
      const P = amount => new Intl.NumberFormat(locale, {style: "percent", maximumFractionDigits: 2}).format(amount);

      const addTrade = () => {
        setEditingTrade({
          symbol: "",
          executions: [],
          tags: [],
        });
        setOnSaveTrade(() => trade => DB.add("trades", prepareTrade(trade)));
        setShowTradeEntry(true);
      };
      const editTrade = trade => {
        setEditingTrade(structuredClone(trade));
        setOnSaveTrade(() => trade => DB.put("trades", prepareTrade(trade)));
        setShowTradeEntry(true);
      };
      const removeTrade = trade => DB.delete("trades", trade.id);

      useEffect(() => localStorage.setItem("locale", locale), [locale]);
      useEffect(() => localStorage.setItem("theme", theme), [theme]);
      useEffect(() => localStorage.setItem("currency", currency), [currency]);
      useEffect(() => {
        const handler = () => DB.getAll("trades").then(request => (request.onsuccess = e => setTrades(e.target.result)));
        handler();
        document.addEventListener("ondbchange", handler);
        return () => document.removeEventListener("ondbchange", handler);
      }, []);

      return (
        h("div", null,
          h("style", null, `
            body {
              font-family: Helvetica, Arial, sans-serif;
              background-color: ${S("background-primary")};
              color: ${S("text-primary")};
            }

            a { color: ${S("accent")}; }

            nav {
              display: flex;
            }

            nav * {
              align-self: center;
            }

            .spacer {
              flex-grow: 1;
            }

            .trade-stats {
              display: flex;
              flex-wrap: wrap;
              justify-content: space-evenly;
            }

            .trade-stats span {
              margin: 10px;
              background-color: ${S("background-secondary")};
              padding: 10px;
              border: 4px solid ${S("text-primary")};
              border-radius: 4px;
            }

            .trade-table {
              width: fit-content;
              margin: 0 auto;
            }

            table {
              border-collapse: collapse;
              white-space: nowrap;
            }

            th, td {
              padding: 3px;
              border: 2px solid ${S("text-primary")};
            }

            th {
              text-align: start;
              border-bottom: 3px solid ${S("text-primary")};
            }

            td {
              text-align: end;
            }

            footer {
              display: flex;
              flex-direction: column;
              align-items: center;
            }
          `),
          h("nav", null,
            h("h1", null, "Stonkla"),
            h("div", {className: "spacer"}),
            h("button", {onClick: addTrade}, T("app-add-trade-button")),
            h("button", {onClick: () => setShowTradeImportExport(true)}, T("app-import-export-button")),
            h("button", {onClick: () => setShowAppSettings(true)}, T("app-open-settings-button")),
          ),
          showAppSettings && h(AppSettings, {T, locale, setLocale, theme, setTheme, currency, setCurrency, closeSelf: () => setShowAppSettings(false)}),
          showTradeEntry && h(TradeEntry, {T, trade: editingTrade, setTrade: setEditingTrade, onSaveTrade, closeSelf: () => setShowTradeEntry(false)}),
          showTradeImportExport && h(TradeImportExport, {T, trades, closeSelf: () => setShowTradeImportExport(false)}),
          h(TradeStats, {T, C, P, trades}),
          h(TradeTable, {T, locale, C, trades, setTrades, editTrade, removeTrade}),
          h("footer", null,
            h("span", null, T("app-made-with-love-text")),
            h("span", null, h("a", {href: "https://github.com/sponsors/dawsonfrakes", target: "_blank"}, T("app-sponsor-on-github-link"))),
          ),
        )
      );
    };

    render(h(App), document.body);
  </script>
</body>
</html>
