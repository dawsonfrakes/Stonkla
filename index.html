<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stonkla</title>
</head>
<body>
  <script type="module">
    import {h, render, createContext} from 'https://esm.sh/preact';
    import {useState, useEffect, useContext, useRef} from 'https://esm.sh/preact/hooks';

    const DB = (() => {
      const dbchange = new CustomEvent("dbchange");
      const inner = new Promise((resolve, reject) => {
        const request = indexedDB.open("stonkla", 1);
        request.onsuccess = e => resolve(e.target.result);
        request.onerror = e => reject(e.target.error);
        request.onupgradeneeded = e => {
          const db = e.target.result;
          if (db.version >= 1) {
            const store = db.createObjectStore("trades", {keyPath: "id", autoIncrement: true});
            store.createIndex("executions", "executions");
            store.createIndex("tags", "tags");
          }
        };
      });
      return {
        add: (store, value) => {
          inner.then(db => db.transaction(store, "readwrite").objectStore(store).add(value));
          document.dispatchEvent(dbchange);
        },
        put: (store, value) => {
          inner.then(db => db.transaction(store, "readwrite").objectStore(store).put(value));
          document.dispatchEvent(dbchange);
        },
        delete: (store, id) => {
          inner.then(db => db.transaction(store, "readwrite").objectStore(store).delete(id));
          document.dispatchEvent(dbchange);
        },
        bulkAdd: (store, values) => {
          inner.then(db => {
            const transaction = db.transaction(store, "readwrite");
            values.forEach(value => transaction.objectStore(store).add(value));
          });
          document.dispatchEvent(dbchange);
        },
        clear: store => {
          inner.then(db => db.transaction(store, "readwrite").objectStore(store).clear());
          document.dispatchEvent(dbchange);
        },
        get: (store, id) => new Promise((resolve, reject) => {
          inner.then(db => {
            const request = db.transaction(store).objectStore(store).get(id);
            request.onsuccess = e => resolve(e.target.result ?? null);
            request.onerror = e => reject(e.target.error);
          });
        }),
        getAll: store => new Promise((resolve, reject) => {
          inner.then(db => {
            const request = db.transaction(store).objectStore(store).getAll();
            request.onsuccess = e => resolve(e.target.result ?? []);
            request.onerror = e => reject(e.target.error);
          });
        }),
      };
    })();

    const TRANSLATIONS = {
      "en": {
        "translation-name": "English",
        "app-add-trade": "Add Trade",
        "app-privacy-notice": `NOTICE: Your data is private and I don't want it. This app uses IndexedDB to store trades locally in your browser. Please make regular backups using the "Export to CSV" feature. Breaking changes to the site may occur without notice. Storing your data offline is the safest way to use this site.`,
        "app-made-with-love": "Made with ❤️ by Dfra",
        "app-sponsor-link": "Sponsor on GitHub",
        "app-settings-locale-label": "Locale:",
        "app-settings-theme-label": "Theme:",
        "app-settings-currency-label": "Currency:",
        "app-settings-remove-all-trades": "Remove All Trades",
        "app-settings-remove-all-trades-confirm": "Are you sure you want to remove all trades?",
        "trade-import-export-csv-type-select": "CSV Type:",
        "trade-import-export-import-button": "Import from CSV",
        "trade-import-export-export-button": "Export to CSV",
        "trade-entry-symbol-input": "Symbol:",
        "trade-entry-tags-input": "Tags:",
        "trade-entry-buy-button": "BUY",
        "trade-entry-sell-button": "SELL",
        "trade-entry-time-input": "Time:",
        "trade-entry-quantity-input": "Quantity:",
        "trade-entry-price-input": "Price:",
        "trade-entry-fees-input": "Fees:",
        "trade-entry-symbol-placeholder": "Symbol",
        "trade-entry-tags-placeholder": "Tags",
        "trade-entry-time-placeholder": "Time",
        "trade-entry-quantity-placeholder": "Quantity",
        "trade-entry-price-placeholder": "Price",
        "trade-entry-fees-placeholder": "Fees",
        "trade-entry-add-execution": "Add Execution",
        "trade-entry-delete-execution": "Remove",
        "trade-entry-save": "Save",
        "trade-entry-cancel": "Cancel",
        "trade-table-time": "Time",
        "trade-table-symbol": "Symbol",
        "trade-table-status": "Status",
        "trade-table-entry-total": "Entry Total",
        "trade-table-exit-total": "Exit Total",
        "trade-table-net-pl": "Net P/L",
        "trade-table-tags": "Tags",
        "trade-table-edit": "Edit",
        "trade-table-remove": "Remove",
        "trade-table-status-win": "WIN",
        "trade-table-status-loss": "LOSS",
        "trade-stats-total-profit-loss": "Total Profit/Loss",
        "trade-stats-win-count": "Win Count",
        "trade-stats-loss-count": "Loss Count",
        "trade-stats-total-trades": "Total Trades",
        "trade-stats-win-percentage": "Win Percentage",
        "trade-stats-largest-win": "Largest Win",
        "trade-stats-largest-loss": "Largest Loss",
        "trade-stats-average-win": "Average Win",
        "trade-stats-average-loss": "Average Loss",
      },
      "es": {
        "translation-name": "Español",
        "app-add-trade": "Añadir Operación",
        "app-privacy-notice": `AVISO: Tus datos son privados y no los quiero. Esta aplicación utiliza IndexedDB para almacenar operaciones localmente en tu navegador. Por favor, haz copias de seguridad regulares utilizando la función "Exportar a CSV". Cambios en el sitio pueden ocurrir sin previo aviso. Almacenar tus datos sin conexión es la forma más segura de usar este sitio.`,
        "app-made-with-love": "Hecho con ❤️ por Dfra",
        "app-sponsor-link": "Patrocinar en GitHub",
        "app-settings-locale-label": "Lugar:",
        "app-settings-theme-label": "Tema:",
        "app-settings-currency-label": "Divisa:",
        "app-settings-remove-all-trades": "Eliminar Todas las Operaciones",
        "app-settings-remove-all-trades-confirm": "¿Estás seguro de que quieres eliminar todas las operaciones?",
        "trade-import-export-csv-type-select": "Tipo de CSV:",
        "trade-import-export-import-button": "Importar desde CSV",
        "trade-import-export-export-button": "Exportar a CSV",
        "trade-entry-symbol-input": "Símbolo:",
        "trade-entry-tags-input": "Etiquetas:",
        "trade-entry-buy-button": "COMPRA",
        "trade-entry-sell-button": "VENTA",
        "trade-entry-time-input": "Hora:",
        "trade-entry-quantity-input": "Cantidad:",
        "trade-entry-price-input": "Precio:",
        "trade-entry-fees-input": "Comisiones:",
        "trade-entry-symbol-placeholder": "Símbolo",
        "trade-entry-tags-placeholder": "Etiquetas",
        "trade-entry-time-placeholder": "Hora",
        "trade-entry-quantity-placeholder": "Cantidad",
        "trade-entry-price-placeholder": "Precio",
        "trade-entry-fees-placeholder": "Comisiones",
        "trade-entry-add-execution": "Añadir Ejecución",
        "trade-entry-delete-execution": "Eliminar",
        "trade-entry-save": "Guardar",
        "trade-entry-cancel": "Cancelar",
        "trade-table-time": "Hora",
        "trade-table-symbol": "Símbolo",
        "trade-table-status": "Estado",
        "trade-table-entry-total": "Total de Entrada",
        "trade-table-exit-total": "Total de Salida",
        "trade-table-net-pl": "P/L Neto",
        "trade-table-tags": "Etiquetas",
        "trade-table-edit": "Editar",
        "trade-table-remove": "Eliminar",
        "trade-table-status-win": "GANANCIA",
        "trade-table-status-loss": "PÉRDIDA",
        "trade-stats-total-profit-loss": "Total de Ganancias/Pérdidas",
        "trade-stats-win-count": "Conteo de Ganancias",
        "trade-stats-loss-count": "Conteo de Pérdidas",
        "trade-stats-total-trades": "Total de Operaciones",
        "trade-stats-win-percentage": "Porcentaje de Ganancias",
        "trade-stats-largest-win": "Mayor Ganancia",
        "trade-stats-largest-loss": "Mayor Pérdida",
        "trade-stats-average-win": "Promedio de Ganancias",
        "trade-stats-average-loss": "Promedio de Pérdidas",
      },
    };
    console.assert(Object.keys(TRANSLATIONS).every(l => Object.keys(TRANSLATIONS[l]).reduce((acc, key, i) => acc && key === Object.keys(TRANSLATIONS[Object.keys(TRANSLATIONS)[0]])[i])), "All locales must have the same keys.");

    const THEMES = {
      "suisei-dark": {
        "background-primary": "#3b4a62",
        "background-secondary": "lightgray",
        "text-primary": "#dbdeeb",
        "text-secondary": "#affaff",
        "accent": "#fe9841",
      },
      "suisei-light": {
        "background-primary": "#c4b59d",
        "background-secondary": "gray",
        "text-primary": "#242114",
        "text-secondary": "#500500",
        "accent": "#0167be",
      },
    };
    console.assert(Object.keys(THEMES).every(t => Object.keys(THEMES[t]).reduce((acc, key, i) => acc && key === Object.keys(THEMES[Object.keys(THEMES)[0]])[i]), "All themes must have the same keys."));

    const offsetDate = date => new Date(date - new Date().getTimezoneOffset() * 60 * 1000);

    const currentMinute = () => {
      const date = offsetDate(new Date());
      date.setSeconds(0, 0);
      return date.toISOString().slice(0, -1);
    };

    const downloadTextFile = (type, filename, text) => {
      const blob = new Blob([text], {type});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      [a.href, a.download] = [url, filename];
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    };

    const prepareTrade = trade => ({
      ...trade,
      executions: trade.executions.map(execution => ({
        ...execution,
        time: new Date(execution.time).toISOString().slice(0, -1),
        quantity: parseFloat(execution.quantity),
        price: parseFloat(execution.price),
        fees: parseFloat(execution.fees),
      })),
      tags: trade.tags.filter(tag => tag !== ""),
    });

    const LocaleContext = createContext(null);
    const ThemeContext = createContext(null);
    const CurrencyContext = createContext(null);

    const TradeTable = ({trades, setTrades, editTrade}) => {
      const {T, locale} = useContext(LocaleContext);
      const {C} = useContext(CurrencyContext);

      useEffect(() => {
        const handler = () => DB.getAll("trades").then(trades => setTrades(trades));
        handler();
        document.addEventListener("dbchange", handler);
        return () => document.removeEventListener("dbchange", handler);
      }, []);

      const entryTotal = trade => trade.executions.reduce((acc, execution) => acc + (execution.quantity * execution.price + execution.fees) * (execution.action === "BUY"), 0);
      const exitTotal = trade => trade.executions.reduce((acc, execution) => acc + (execution.quantity * execution.price - execution.fees) * (execution.action === "SELL"), 0);

      return (
        h("div", {class: "overflow-auto"},
          h("table", null,
            h("thead", null,
              h("tr", null,
                h("th", null, T("trade-table-time")),
                h("th", null, T("trade-table-symbol")),
                h("th", null, T("trade-table-status")),
                h("th", null, T("trade-table-entry-total")),
                h("th", null, T("trade-table-exit-total")),
                h("th", null, T("trade-table-net-pl")),
                h("th", null, T("trade-table-tags")),
                h("th", null, T("trade-table-edit")),
                h("th", null, T("trade-table-remove")),
              ),
            ),
            h("tbody", null,
              trades.map(trade => h("tr", {key: trade.id},
                h("td", null, new Date(trade.executions[0].time).toLocaleString(locale)),
                h("td", null, trade.symbol),
                h("td", null, exitTotal(trade) - entryTotal(trade) >= 0.0 ? T("trade-table-status-win") : T("trade-table-status-loss")),
                h("td", null, C(entryTotal(trade))),
                h("td", null, C(exitTotal(trade))),
                h("td", null, C(exitTotal(trade) - entryTotal(trade))),
                h("td", null, trade.tags.join(";")),
                h("td", null, h("button", {onClick: () => editTrade(trade)}, T("trade-table-edit"))),
                h("td", null, h("button", {onClick: () => DB.delete("trades", trade.id)}, T("trade-table-remove"))),
              )),
            ),
          )
        )
      );
    };

    const TradeStats = ({trades}) => {
      const {T, P} = useContext(LocaleContext);
      const {C} = useContext(CurrencyContext);

      const netProfitLosses = trades.map(trade => trade.executions.reduce((acc, execution) => acc + (execution.quantity * execution.price) * (execution.action === "BUY" ? -1 : 1) - execution.fees, 0));
      const total = netProfitLosses.reduce((acc, net) => acc + net, 0);
      const wins = netProfitLosses.filter(net => net >= 0.0);
      const losses = netProfitLosses.filter(net => net < 0.0);
      const largestWin = wins.reduce((acc, net) => Math.max(acc, net), 0);
      const largestLoss = losses.reduce((acc, net) => Math.min(acc, net), 0);
      const averageWin = wins.reduce((acc, net) => acc + net, 0) / (wins.length || 1);
      const averageLoss = losses.reduce((acc, net) => acc + net, 0) / (losses.length || 1);

      return (
        h("div", null,
          `${T("trade-stats-total-profit-loss")}: ${C(total)}`,
          h("br"),
          `${T("trade-stats-win-count")}: ${wins.length}`,
          h("br"),
          `${T("trade-stats-loss-count")}: ${losses.length}`,
          h("br"),
          `${T("trade-stats-total-trades")}: ${wins.length + losses.length}`,
          h("br"),
          `${T("trade-stats-win-percentage")}: ${P(wins.length / ((wins.length + losses.length) || 1))}`,
          h("br"),
          `${T("trade-stats-largest-win")}: ${C(largestWin)}`,
          h("br"),
          `${T("trade-stats-largest-loss")}: ${C(largestLoss)}`,
          h("br"),
          `${T("trade-stats-average-win")}: ${C(averageWin)}`,
          h("br"),
          `${T("trade-stats-average-loss")}: ${C(averageLoss)}`,
        )
      );
    };

    const TradeImportExport = ({trades}) => {
      const importFileRef = useRef(null);
      const {T} = useContext(LocaleContext);
      const [importType, setImportType] = useState("stonkla");

      const importCSV = e => {
        e.preventDefault();
        const file = importFileRef.current.files[0];
        const reader = new FileReader();
        reader.onload = e => {
          let newTrades = [];
          if (importType === "stonkla") {
            const rows = e.target.result.split("\n").slice(1).filter(line => line !== "").map(line => line.split(","));
            for (let i = 0; i < rows.length; ) {
              const [start_id, symbol, tags] = [...rows[i].slice(0, 2), rows[i][7].split(";")];
              const executions = [];
              while (i < rows.length) {
                let [id, _symbol, action, time, quantity, price, fees, _tags] = rows[i];
                if (id !== start_id) break;
                executions.push({action, time, quantity, price, fees});
                i += 1;
              }
              newTrades.push(prepareTrade({symbol, executions, tags}));
            }
          } else if (importType === "lightspeed") {
            const lines = e.target.result.split("\n");
            const headers = lines[0].split(",");
            const rows = lines.slice(1).filter(line => line !== "").map(line => line.split(","));
            const data = rows.map(row => Object.fromEntries(row.map((value, i) => [headers[i], value])));
            for (let i = 0; i < data.length; ) {
              const get = key => data[i][`"${key}"`].slice(1, -1).trim();
              const start_symbol = get("Symbol");
              const tags = ["Lightspeed"];
              const executions = [];
              while (i < data.length) {
                const [symbol, action, time, quantity, price, fees] = [
                  get("Symbol"),
                  get("Side") === "B" ? "BUY" : "SELL",
                  offsetDate(new Date(get("Raw Exec. Time"))),
                  Math.abs(parseFloat(get("Qty"))),
                  get("Price"),
                  parseFloat(get("Commission Amount")) + parseFloat(get("Fee1")) + parseFloat(get("Fee2")) + parseFloat(get("Fee3")) + parseFloat(get("Fee4")) + parseFloat(get("FeeMF")) + parseFloat(get("FeeSEC")) + parseFloat(get("FeeStamp")) + parseFloat(get("FeeTAF")),
                ];
                if (symbol !== start_symbol) break;
                executions.push({action, time, quantity, price, fees});
                i += 1;
              }
              newTrades.push(prepareTrade({symbol: start_symbol, executions, tags}));
            }
          }
          DB.bulkAdd("trades", newTrades)
        };
        reader.readAsText(file);
      };

      const exportCSV = () => {
        let result = "id,symbol,action,time,quantity,price,fees,tags\n";
        for (const trade of trades) {
          for (const execution of trade.executions) {
            result += trade.id + ",";
            result += trade.symbol + ",";
            result += execution.action + ",";
            result += execution.time + ",";
            result += execution.quantity + ",";
            result += execution.price + ",";
            result += execution.fees + ",";
            result += trade.tags.join(";") + "\n";
          }
        }
        downloadTextFile("text/csv", "trades.csv", result);
      };

      return (
        h("div", null,
          h("form", {onSubmit: importCSV},
            h("label", {for: "trade-import-export-csv-type-select"}, T("trade-import-export-csv-type-select")),
            h("select", {id: "trade-import-export-csv-type-select", value: importType, onChange: e => setImportType(e.target.value)},
              h("option", {value: "stonkla"}, "Stonkla"),
              h("option", {value: "lightspeed"}, "Lightspeed"),
            ),
            h("input", {ref: importFileRef, type: "file", required: true}),
            h("button", null, T("trade-import-export-import-button")),
          ),
          h("button", {onClick: exportCSV}, T("trade-import-export-export-button")),
        )
      );
    };

    const TradeEntry = ({trade, setTrade, onSave, closeSelf}) => {
      const {T} = useContext(LocaleContext);

      const addExecution = () => {
        const executions = [...trade.executions];
        executions.push({
          action: executions.length !== 0 && executions[executions.length - 1].action === "BUY" ? "SELL" : "BUY",
          time: executions.length !== 0 ? executions[executions.length - 1].time : currentMinute(),
          quantity: executions.length !== 0 ? executions[executions.length - 1].quantity : "",
          price: executions.length !== 0 ? executions[executions.length - 1].price : "",
          fees: executions.length !== 0 ? executions[executions.length - 1].fees : "",
        });
        setTrade({...trade, executions});
      };

      const updateExecution = (i, value) => {
        const executions = [...trade.executions];
        Object.assign(executions[i], value);
        setTrade({...trade, executions});
      };

      const deleteExecution = i => {
        const executions = [...trade.executions.slice(0, i), ...trade.executions.slice(i + 1)];
        setTrade({...trade, executions});
      };

      const onSubmit = e => {
        e.preventDefault();
        onSave(trade);
        closeSelf();
      };

      useEffect(() => { if (trade.executions.length === 0) addExecution(); }, []);

      return (
        h("div", null,
          h("form", {onSubmit},
            h("div", null,
              h("label", {for: "trade-entry-symbol-input"}, T("trade-entry-symbol-input")),
              h("input", {id: "trade-entry-symbol-input", type: "text", required: true, placeholder: T("trade-entry-symbol-placeholder"), value: trade.symbol, onInput: e => setTrade({...trade, symbol: e.target.value.toUpperCase().replace(/[^A-Z]/g, "").slice(0, 5)})}),
              h("label", {for: "trade-entry-tags-input"}, T("trade-entry-tags-input")),
              h("input", {id: "trade-entry-tags-input", type: "text", placeholder: T("trade-entry-tags-placeholder"), value: trade.tags.join(";"), onInput: e => setTrade({...trade, tags: e.target.value.replace(/,/g, "").split(";")})}),
            ),
            trade.executions.map((execution, i) => h("div", {key: i},
              h("button", {type: "button", onClick: () => deleteExecution(i), disabled: trade.executions.length === 1}, T("trade-entry-delete-execution")),
              h("button", {type: "button", onClick: () => updateExecution(i, {action: execution.action === "BUY" ? "SELL" : "BUY"})}, execution.action === "BUY" ? T("trade-entry-buy-button") : T("trade-entry-sell-button")),
              h("label", {for: "trade-entry-time-input" + i}, T("trade-entry-time-input")),
              h("input", {id: "trade-entry-time-input" + i, type: "datetime-local", required: true, step: "1", value: execution.time, onInput: e => updateExecution(i, {time: e.target.value})}),
              h("label", {for: "trade-entry-quantity-input" + i}, T("trade-entry-quantity-input")),
              h("input", {id: "trade-entry-quantity-input" + i, type: "number", required: true, placeholder: T("trade-entry-quantity-placeholder"), min: "0", step: "0.0001", value: execution.quantity, onInput: e => updateExecution(i, {quantity: e.target.value})}),
              h("label", {for: "trade-entry-price-input" + i}, T("trade-entry-price-input")),
              h("input", {id: "trade-entry-price-input" + i, type: "number", required: true, placeholder: T("trade-entry-price-placeholder"), min: "0", step: "0.0001", value: execution.price, onInput: e => updateExecution(i, {price: e.target.value})}),
              h("label", {for: "trade-entry-fees-input" + i}, T("trade-entry-fees-input")),
              h("input", {id: "trade-entry-fees-input" + i, type: "number", required: true, placeholder: T("trade-entry-fees-placeholder"), step: "0.0001", value: execution.fees, onInput: e => updateExecution(i, {fees: e.target.value})}),
            )),
            h("button", {type: "button", onClick: addExecution}, T("trade-entry-add-execution")),
            h("button", null, T("trade-entry-save")),
          ),
          h("button", {onClick: closeSelf}, T("trade-entry-cancel")),
        )
      );
    };

    const AppSettings = () => {
      const {T, locale, setLocale} = useContext(LocaleContext);
      const {S, theme, setTheme} = useContext(ThemeContext);
      const {C, currency, setCurrency} = useContext(CurrencyContext);

      return (
        h("div", null,
          h("label", {for: "app-settings-locale-select"}, T("app-settings-locale-label")),
          h("select", {id: "app-settings-locale-select", onChange: e => setLocale(e.target.value), value: locale},
            Object.keys(TRANSLATIONS).map(l => h("option", {key: l, value: l}, TRANSLATIONS[l]["translation-name"])),
          ),
          h("label", {for: "app-settings-theme-select"}, T("app-settings-theme-label")),
          h("select", {id: "app-settings-theme-select", onChange: e => setTheme(e.target.value), value: theme},
            Object.keys(THEMES).map(t => h("option", {key: t, value: t}, t)),
          ),
          h("label", {for: "app-settings-currency-select"}, T("app-settings-currency-label")),
          h("select", {id: "app-settings-currency-select", onChange: e => setCurrency(e.target.value), value: currency},
            ["USD", "GBP", "EUR", "JPY", "CAD"].map(c => h("option", {key: c, value: c}, c)),
          ),
          h("button", {style: "color: red", onClick: () => confirm(T("app-settings-remove-all-trades-confirm")) && DB.clear("trades")}, T("app-settings-remove-all-trades")),
        )
      );
    };

    const App = () => {
      const defaultLocale = localStorage.getItem("locale") ?? navigator.language.slice(0, 2);
      const defaultTheme = localStorage.getItem("theme") ?? "suisei-light";
      const defaultCurrency = localStorage.getItem("currency") ?? "USD";

      const [locale, setLocale] = useState(defaultLocale in TRANSLATIONS ? defaultLocale : Object.keys(TRANSLATIONS)[0]);
      const [theme, setTheme] = useState(defaultTheme in THEMES ? defaultTheme : Object.keys(THEMES)[0]);
      const [currency, setCurrency] = useState(defaultCurrency);
      const [showTradeEntry, setShowTradeEntry] = useState(false);
      const [tradeEntrySave, setTradeEntrySave] = useState(null);
      const [editingTrade, setEditingTrade] = useState(null);
      const [trades, setTrades] = useState([]);

      const T = key => TRANSLATIONS[locale][key] ?? console.error(`Missing translation for key "${key}" in locale "${locale}".`);
      const S = key => THEMES[theme][key] ?? console.error(`Missing style for key "${key}" in theme "${theme}".`);
      const C = amount => new Intl.NumberFormat(locale, {style: "currency", currency}).format(amount);
      const P = amount => new Intl.NumberFormat(locale, {style: "percent", maximumFractionDigits: 2}).format(amount);

      useEffect(() => localStorage.setItem("locale", locale), [locale]);
      useEffect(() => localStorage.setItem("theme", theme), [theme]);
      useEffect(() => localStorage.setItem("currency", currency), [currency]);

      const newTrade = () => {
        if (showTradeEntry) return;
        setEditingTrade({symbol: "", executions: [], tags: []});
        setTradeEntrySave(() => trade => DB.add("trades", prepareTrade(trade)));
        setShowTradeEntry(true);
      };

      const editTrade = trade => {
        if (showTradeEntry) return;
        setEditingTrade(trade);
        setTradeEntrySave(() => trade => DB.put("trades", prepareTrade(trade)));
        setShowTradeEntry(true);
      };

      return (
        h(LocaleContext.Provider, {value: {T, P, locale, setLocale}},
        h(ThemeContext.Provider, {value: {S, theme, setTheme}},
        h(CurrencyContext.Provider, {value: {C, currency, setCurrency}},
          h("style", null, `
            body {
              font-family: Helvetica, Arial, sans-serif;
              background-color: ${S("background-primary")};
              color: ${S("text-primary")};
            }
            a { color: ${S("accent")}; }

            .overflow-auto { overflow: auto; }

            table { text-align: left; border-collapse: collapse; }
            thead { border-block-end: 2px solid; }
            th, td {
              border: 1px solid ${S("background-secondary")};
              padding: 0.15rem 0.25rem;
              word-break: keep-all;
            }
            tbody tr:nth-child(even) { background: color-mix(in srgb, ${S("background-secondary")}, transparent 80%); }
            th { text-align: start; }
            td { text-align: end; }
          `),
          h("h1", null, "Stonkla"),
          h(AppSettings),
          showTradeEntry &&
            h(TradeEntry, {trade: editingTrade, setTrade: setEditingTrade, onSave: tradeEntrySave, closeSelf: () => setShowTradeEntry(false)}) ||
            h("div", null, h("button", {onClick: newTrade}, T("app-add-trade"))),
          h(TradeImportExport, {trades}),
          h(TradeStats, {trades}),
          h(TradeTable, {trades, setTrades, editTrade}),
          h("p", null,
            T("app-privacy-notice"),
            h("br"),
            T("app-made-with-love"),
            h("br"),
            h("a", {href: "https://github.com/sponsors/dawsonfrakes", target: "_blank"}, T("app-sponsor-link")),
          ),
        )))
      );
    };

    render(h(App), document.body);
  </script>
</body>
</html>
